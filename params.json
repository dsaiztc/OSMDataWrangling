{"name":"Osmdatawrangling","tagline":"OpenStreetMaps Data Wrangling.","body":"# OpenStreetMaps Data Wrangling\r\n\r\n> This project has been developed in order to pursue the [Data Analyst Nanodegree](https://www.udacity.com/course/data-analyst-nanodegree--nd002) offered by Udacity. Specifically, the project aims to use the knowledges acquired in the second course of this Nanodegree: [Data Wrangling with MongoDB](https://www.udacity.com/course/ud032-nd).\r\n> \r\n> The *Project Report* about the data wrangling can be found [here](https://github.com/dsaiztc/OSMDataWrangling/blob/master/ProjectReport.md).\r\n\r\n## 1. Introduction\r\n\r\nThe goal of this project is to choose any area of the world in [https://www.openstreetmap.org](https://www.openstreetmap.org/) and use data munging techniques, such as assessing the quality of the data for validity, accuracy, completeness, consistency and uniformity, to clean the *OpenStreetMap* data for a part of the world, converting it from XML to JSON format, importing the clean file into a *MongoDB* database and run some queries against it.\r\n\r\n## 2. Obtaining the data\r\n\r\nTo obtain the data I have made a query to `http://overpass-api.de/query_form.html` after searching for [*Las Merindades*](https://www.openstreetmap.org/relation/4718122#map=10/42.9408/-3.4854), which is the region where my hometown, [*Medina de Pomar*](https://en.wikipedia.org/wiki/Medina_de_Pomar), belongs to. The query is the following:\r\n\r\n``` \r\n(node(42.5966, -4.2339, 43.2832, -2.7370);<;);out meta;\r\n```\r\n\r\nAnd the resulting `osm` (or `xml`) data is stored on `/data/file.osm`, which is a *355,3 MB* file (that can be downloaded also [here](https://www.dropbox.com/s/9d8io7q19lkq2b1/merindades.osm?dl=0)). A *sample* of that file (created with the [sample.py](./src/sample.py) script) can be accessed [here](./data/sample.osm).\r\n\r\n![Maps of Las Merindades (Spain)](./images/map.png)\r\n\r\n## 3. Structure of the OSM file\r\n\r\nIn the [OSM XML page](http://wiki.openstreetmap.org/wiki/OSM_XML) we can see the format of the XML document, which is basically a list of instances of their *data primitives* or [Elements](http://wiki.openstreetmap.org/wiki/Elements): [nodes](http://wiki.openstreetmap.org/wiki/Node), [ways](http://wiki.openstreetmap.org/wiki/Way) and [relations](http://wiki.openstreetmap.org/wiki/Relation). \r\n\r\n### 3.1 Elements\r\n\r\nThose *Elements* have several [common attributes](http://wiki.openstreetmap.org/wiki/Elements#Common_attributes): **id** (identify the element within a type -node, way or relation-), **user** (display name of the  user), **uid** (numeric user id), **timestamp** (time of the last modification), **visible** (whether the object is deleted or not in the database), **version** (edit version of the object) and **changeset** (the [changeset](http://wiki.openstreetmap.org/wiki/Changeset) in which the object was created or updated).\r\n\r\nFurthermore, each one of those *categories* has its own attributes:\r\n\r\n- *Nodes*: **lat** (latitude coordinates in degrees), **lon** (longitude coordinates in degrees) and a bunch of different [tags](http://wiki.openstreetmap.org/wiki/Tags) (a set of key/value pairs).\r\n- *Ways*: an ordered list of *Nodes* (as XML elements with **nd** tag and an attribute named *ref* with a reference to the *node id*). Normally it has also at least one [tag](http://wiki.openstreetmap.org/wiki/Tags).\r\n- *Relations*: one or more [tags](http://wiki.openstreetmap.org/wiki/Tags) and also an ordered list of one or more *nodes*, *ways* and *relations* as members.\r\n\r\nSo our interest will be on the first two kind of *Elements*: *nodes* and *ways*. The majority of the *common attributes* make a reference to the *creation* process of that element. So in our *document-oriented* model we could aggregate those values within an attribute of our document. Also, due to the fact that there is going to be a unique collection for all documents, we should differentiate between *nodes* and *ways*.\r\n\r\n``` javascript\r\n{\r\n...\r\n'type': 'node OR way',\r\n'id': 'some_id',\r\n'visible': 'true OR false',\r\n'created': {\r\n\t'user': 'some_user',\r\n    'uid': 'some_uid',\r\n    'timestamp': 'some_timestamp',\r\n    'version': 'some_version',\r\n    'changeset': 'some_changeset'\r\n    }\r\n}\r\n```\r\n\r\nIn the case of *nodes*, we could add a *position* attribute. MongoDB offers a number of [indexes and query](http://docs.mongodb.org/manual/applications/geospatial-indexes/) mechanisms to handle geospatial information, that allows us to create [2d Geospatial Indexes](http://docs.mongodb.org/v2.2/core/geospatial-indexes/) if we storage the GPS data with the following format:\r\n\r\n``` javascript\r\n'pos' : [ longitude, latitude ]\r\n```\r\n\r\n*NOTE:* the name of the attribute could be whatever we want, *pos* is an option but it could be *loc* or *position*. In our case the name of this attribute will be *pos* (for no specific reason).\r\n\r\nIn the case of *ways*, we could create an attribute for storing all the *nd* values within an array:\r\n\r\nFrom\r\n\r\n``` xml\r\n<way ...>\r\n\t<nd ref='ref1'/>\r\n    <nd ref='ref2'/>\r\n    ...\r\n</way>\r\n```\r\n\r\nto\r\n\r\n``` javascript\r\n{\r\n...\r\n'node_refs': [ 'ref1', 'ref2', ... ]\r\n}\r\n```\r\n\r\n### 3.2 Tags\r\n\r\nAs we have seen before, a [tag](http://wiki.openstreetmap.org/wiki/Tags) is a key/value pair that describes a specific feature of a data *Element*. In our transformation to JSON-like documents we should include all these tags as attributes. However, there are some of this *tags* whose *key* can be modified to include a [namespace](http://wiki.openstreetmap.org/wiki/Namespace) (a prefix, infix or suffix using a colon `:` as separator). One example of these *namespaces* could be the *tags* that contain part of an address, which have a prefix *addr*. In these cases we could create an attribute in our document that aggregate all different characteristics for a given prefix, which in the case of an address could be:\r\n\r\nFrom\r\n\r\n``` xml\r\n<node ...>\r\n  ...\r\n  <tag k='addr:street' v='some_street'/>\r\n  <tag k='addr:postcode' v='some_postcode'/>\r\n  <tag k='addr:housenumber' v='some_housenumber'/>\r\n</node>\r\n```\r\n\r\nto\r\n\r\n``` javascript\r\n{\r\n'type': 'node',\r\n...\r\n'addr': {\r\n\t'street': 'some_street',\r\n    'postcode': 'some_postcode',\r\n    'housenumber': 'some_housenumber'\r\n    }\r\n}\r\n```\r\n\r\n## 4. Auditing the data\r\n\r\nWe are going to assume that **all the attributes, except for the *tags*, are going to be correct**. That is, the *common attributes*, the GPS positions for the *nodes* and the list of nodes for the *ways* are not going to be sanity checked.\r\n\r\nAs we have seen before, each *tag* has a *key/value pair* referring a specific characteristic of that *node* or *way*. We are going to audit first the *keys*, and then we will continue with the *values*.\r\n\r\n### 4.1 Analyzing the different *keys*\r\n\r\n#### 4.1.1 Structure (applying *regular expressions*)\r\n\r\n> This analysis has been performed with different functions within the [audit_keys_basic.py](./src/audit_keys_basic.py) script.\r\n\r\nIf we take a look at the *tags* presented in the document, classifying their *key* depending on the kind of *Element* (*node* or *way*) and also the structure (if all the characters are correct or if it has a namespace, for example) we get the following structure:\r\n\r\n``` javascript\r\n{'node': {'lower': 89359,\r\n          'lower_colon': 53673,\r\n          'lower_colon2': 171,\r\n          'other': 344,\r\n          'problemchars': 0},\r\n 'way': {'lower': 206635,\r\n         'lower_colon': 34756,\r\n         'lower_colon2': 250,\r\n         'other': 22,\r\n         'problemchars': 1}}\r\n```\r\n\r\nIn this case we have made a count of the different categories: ***lower*** represents all the *keys* that are composed by lower case characters and/or the underscore (ex. `admin_level`), ***lower_colon*** represents all the *keys* that have the same structure as the previous but that also includes one namespace (ex. `addr:city`), *lower_colon2* **represents** all the *keys* that have the same structure as *lower* but that includes two namespaces (ex. `maxspeed:lanes:forward`), ***problemchars*** represents all the values with one or more problematic characters (other than `a-z` or `_`) and finally ***other*** represents all the other cases.\r\n\r\nAs we said before, we can nest the keys with namespaces within attributes of our JSON-like document. So the *tags* in the categories ***lower_colon*** and ***lower_colon2*** could be treated that way. In the case of the ***lower*** category, we can add directly the *tags* as attributes to our document.\r\n\r\nRegarding the ***other*** category and the problematic characters, we should check what kind of *tags* we have. Following the last procedure, we are going to count how many different *keys* we have for those *tags*:\r\n\r\n``` javascript\r\n{'node': {'lower': { ... },\r\n \t\t 'lower_colon': { ... },\r\n         'lower_colon2': { ... },\r\n         'probemchars': {},         \r\n         'other': {'CODIGO': 3,\r\n                   'FIXME': 2,\r\n                   'fuel:GTL_diesel': 45,\r\n                   'fuel:HGV_diesel': 2,\r\n                   'fuel:diesel_B': 25,\r\n                   'fuel:diesel_C': 1,\r\n                   'fuel:octane_91': 1,\r\n                   'fuel:octane_95': 70,\r\n                   'fuel:octane_98': 48,\r\n                   'ideewfs:alturaElipsoidal': 18,\r\n                   'ideewfs:factorEscala': 18,\r\n                   'ideewfs:fechaCompensacion': 18,\r\n                   'ideewfs:husoUTM': 18,\r\n                   'ideewfs:numeroROI': 18,\r\n                   'ideewfs:xUTM': 18,\r\n                   'ideewfs:yUTM': 18,\r\n                   'naptan:CommonName': 1,\r\n                   'naptan:Indicator': 1,\r\n                   'naptan:Street': 1,\r\n                   'ref:RRG': 18}},\r\n 'way': {'lower': { ... },\r\n \t\t 'lower_colon': { ... },\r\n         'lower_colon2': { ... },\r\n         'probemchars': {u'Torre\\xf3n del castillo de los Salazar': 1},\r\n         'other': {'FIXME': 1,\r\n                   'N': 1,\r\n                   'fuel:GTL_diesel': 2,\r\n                   'fuel:diesel_B': 1,\r\n                   'fuel:octane_95': 9,\r\n                   'fuel:octane_98': 8}}}\r\n```\r\n\r\nAs we can see, most of the cases have been classified into this category because they have capital letters or even numbers. The [OSM wiki](http://wiki.openstreetmap.org/wiki/Tags) specifies that *both the key and value are free format text fields*, however it is not a common practice to include such kind of characters on the *key*. We are going to analyze each one of those values to understand what they mean.\r\n\r\nThe [**FIXME**](http://wiki.openstreetmap.org/wiki/Key:fixme) *key* *\"allows contributors to mark objects and places that need further attention”*. The **CODIGO** *key* does not seem to have any meaning, we will try to understand what it means later. The **N** *key* seems to be some kind of error, we will try to discover its meaning later too. The **naptan** namespace references the [NaPTAN and NPTG](http://wiki.openstreetmap.org/wiki/NaPTAN) datasets for bus stops and places which the [UK Department for Transport](http://www.dft.gov.uk/) and [Traveline](http://www.traveline.org.uk/aboutTL.htm) have offered to make available to OpenStreetMap project, so given that this region belongs to Spain, I suppose these values should not be there. The [**ideewfs**](http://wiki.openstreetmap.org/wiki/ES:RGN) *key* refers to the *Web Feature Services* (WFS) of the *Infraestructura de Datos Espaciales de España* (IDEE - Spatial Data Infrastructure of Spain), which is a web service to consult geographic features of Spain, so this data refers to data that belongs to the *Red Geodésica Nacional* (RGN - National Geodetic Network). The [**ref**](http://wiki.openstreetmap.org/wiki/Key:ref) *key* is used for reference numbers or codes (as we have seen for referencing the *nodes* within a *way*), which in this case has the **RRG** namespace, that is referenced on the RGN (as the **ideewfs**). Nevertheless, I have not found any reference about what it means, so we will treat them the same way as the others. The penultimate element is the [**fuel**](http://wiki.openstreetmap.org/wiki/Key:fuel) *key*, which describes which fuels are available at [amenity](http://wiki.openstreetmap.org/wiki/Key:amenity)=[fuel](http://wiki.openstreetmap.org/wiki/Tag:amenity%3Dfuel) sites. Finally we have a value within the **problemchars** category,  `u'Torre\\xf3n del castillo de los Salazar'` that clearly should not be there because it refers to a name of some kind of castle-like building, so it has to be within the *value* of a **[historic](http://wiki.openstreetmap.org/wiki/Key:historic):castle** *key* (for example).\r\n\r\nSummarizing, we can proceed to storage as attributes in our document the *keys* **FIXME** (because we do not know what that user was referring to) and **fuel**. In the case of **ideewfs** and **ref:RRG**, it turns out that these *nodes* has a *tag* with a **source** *key* pointing to the IDEE, so both reference to the same source. However, we are not sure about the meaning of those *tags*, so we will need further analysis of the *keys*. The case **CODIGO** refers to a some specific trees that are protected by the Basque Government and have a unique identifier that can be consulted [here](http://www.uragentzia.euskadi.net/u81-ecoaguas/es/u95aWar/lugaresJSP/U95aVolverLugares.do?u95aMigasPan=L,1,1,1,3,1,1;L,2,13674,018;H,2,14021,016;L,2,13745,002;EN,1,9,1,300;L,2,13733,007;). They are under the [*Primary Feature* **natural**](http://wiki.openstreetmap.org/wiki/Map_Features#Natural) so we can treat these values as other attributes within our object.\r\n\r\nIn the castle-case, effectively we have the following wrong *tag*: `<tag k=\"Torreón del castillo de los Salazar\" v=\"water\" />`. We do not know what the user wanted to say with the *water* value, but it is clear that the *key* in this case should be moved to a *tag* with a *name key*: `<tag k=\"name\" v=\"Torreón del castillo de los Salazar\" />`. The **N** *key* refers to a street name as the *tag* states: `<tag k=\"N\" v=\"Calle Real\" />`, so we should change it for `<tag k=\"name\" v=\"Calle Real\" />`.\r\n\r\n#### 4.1.2 *Namespaces* and aggregating attributes\r\n\r\n> This analysis has been performed with different functions within the [audit_keys_namespaces.py](./src/audit_keys_namespaces.py) script.\r\n\r\nAs we stated before, the *tags* that belong to a *namespace* are going to be nested within attributes in our JSON document. However, there are some cases where we have a specific *key* and also other *keys* with that same *key* as prefix, for example:\r\n\r\n``` xml\r\n<node changeset=\"12512900\" id=\"571400447\" lat=\"43.2249805\" lon=\"-2.8184747\" timestamp=\"2012-07-27T15:24:07Z\" uid=\"53891\" user=\"nubarron\" version=\"6\">\r\n    <tag k=\"is_in\" v=\"Bizkaia;Euskadi;Spain;Europe\" />\r\n    <tag k=\"is_in:continent\" v=\"Europe\" />\r\n    <tag k=\"is_in:country\" v=\"Spain\" />\r\n    <tag k=\"is_in:municipality\" v=\"Usansolo\" />\r\n    <tag k=\"is_in:province\" v=\"Bizkaia\" />\r\n    <tag k=\"is_in:region\" v=\"Euskadi\" />\r\n    <tag k=\"name\" v=\"Trokarro\" />\r\n    <tag k=\"place\" v=\"suburb\" />\r\n  </node>\r\n```\r\n\r\nHere we have serval *tags* with the **is_in** prefix and one without *namespace*. Moreover, in this case, the *tag* without *namespace* has all the other values separated by a semicolon, so we should probably remove it. This behavior is not always the same, for example:\r\n\r\n``` xml\r\n<node changeset=\"30014663\" id=\"560565243\" lat=\"43.2607099\" lon=\"-2.9271508\" timestamp=\"2015-04-06T12:44:22Z\" uid=\"251029\" user=\"Voidoid\" version=\"5\">\r\n    <tag k=\"amenity\" v=\"bank\" />\r\n    <tag k=\"atm\" v=\"yes\" />\r\n    <tag k=\"atm:network\" v=\"Euro 6000\" />\r\n    <tag k=\"name\" v=\"BBK\" />\r\n  </node>\r\n```\r\n\r\nIn this case the *tag* without *namespace* only states that there is an **atm** (and that we will probably have other *tags* with **atm** as prefix). In this case we should also remove the \"plain\" *tag* as we know that this point do have an atm because it will have an **atm** attribute.\r\n\r\nThe complete list of *tags* that follow this pattern can be shown below:\r\n\r\n``` python\r\n['building', 'population', 'maxspeed', 'lanes', 'name', 'aerialway', 'area', 'social_facility', 'wheelchair', 'atm', 'wikipedia', 'recording', 'source', 'alt_name', 'internet_access', 'is_in']\r\n```\r\n\r\nNevertheless, each individual case could be different. In the case of the [**name**](http://wiki.openstreetmap.org/wiki/Names) for example, we could have a **name** *tag* for the default name and localized names in different languages with suffixes to that *tag* (**name:es** for the spanish name).\r\n\r\nAfter examining all these values, I would conclude that the most reasonable approach is to create a **default** value for the *tag* without *namespace* and add the rest with their corresponding *namespace*. In the example of the **atm**:\r\n\r\n``` javascript\r\n{\r\n...\r\n'atm': {\r\n\t\t'default': 'yes',\r\n        'network': 'Euro 6000'\r\n\t   }\r\n}\r\n```\r\n\r\n### 4.2 Analyzing the *values*\r\n\r\n> This analysis has been performed with different functions within the [audit_values_basic.py](./src/audit_values_basic.py) script.\r\n\r\nNow it is time to analyze all the *values* within the *tags* of the different *Elements*. Given the large amount of different attributes, we are going to focus in those that could be checked in some way, like the [address](http://wiki.openstreetmap.org/wiki/Key:addr) different fields.\r\n\r\nThe address *keys* we have follow a distribution:\r\n\r\n``` javascript\r\n{'addr:city': 1673,\r\n 'addr:country': 937,\r\n 'addr:country_code': 15,\r\n 'addr:full': 13,\r\n 'addr:housename': 33,\r\n 'addr:housenumber': 4804,\r\n 'addr:inclusion': 3,\r\n 'addr:interpolation': 145,\r\n 'addr:place': 2,\r\n 'addr:postcode': 1686,\r\n 'addr:state': 5,\r\n 'addr:street': 4909}\r\n```\r\n\r\nIn this case we can differentiate between three types of values that we will likely find: text-based, numeric and code-based. The last of them references to those categories that do not represent a physical characteristic, but instead are used by OSM: [**addr:inclusion**](http://wiki.openstreetmap.org/wiki/Addresses#Using_Address_Interpolation_for_partial_surveys) and [**addr:interpolation**](http://wiki.openstreetmap.org/wiki/Key:addr:interpolation). We also have a *tag* that represents the full address, **addr:full**, which we are going to leave as it comes, regarding the complexity to parse a field like that.\r\n\r\n#### 4.2.1 Numeric values\r\n\r\nRegarding the numeric values, we have **addr:housenumber** and **addr:postcode**. These two have some variations and it would be better to analyze their structure (like we did with the *keys*). In the case of **postcode** there is one case where we have several values separated by semicolon, which matches with the city of Bilbao (it could probably be a good idea to convert those values into an array in the JSON document). We also have other value `'Larrabetzu'`, which is clearly not a postcode but a city name instead. \r\n\r\nAttending the **housenumber** values, we can see different patterns: with only numbers, with numbers and a capital letter, with a number and a word *bis* (which means that there are two buildings with the same number; it appears close to the number, separated by a space, with capital and non capital letters), with a range of numbers (as a list and also as an interval) and others:\r\n\r\n``` javascript\r\n['SN(B)', 'SN(D)', '7 - 43', '2 - 36', '46, BIS', '2, 4 y 7', u'8, 1\\xba D', '2, 4', '6, 8', '12, 14', '13-15', 'SN(A)', '15-17', '2019.', '1-3', 'SN(C)', 'SN(E)', '4, 6', 'km 508', '4, 6, 8, 10', 's/n', '3, 5, 7, 9', '12-14', '8, 10', '37-39', '12-38']\r\n```\r\n\r\nFor those that have several values the best approach would be to save the values within an array, but we do not know if a range `12-14` includes the number 13 or not (probably not). We have also values with `s/n` which means *sin número* (*without number* in spanish). I suppose the `SN(...)` values refer the same as `s/n` but with a letter instead of a number. However, we have some values that could be corrected.\r\n\r\n#### 4.2.2 Text-based values\r\n\r\nRegarding the text-based values, we have **addr:city**, **addr:country**, **addr:country_code**, **addr:housename**, **addr:place**, **addr:state** and **addr:street**. In the cases of **country**, **country_code** and **state** we have the same value, *ES* (referring to Spain). In the case of **place** we only have two values, one of them does not start with capital letter, but apart from that, they seem correct. \r\n\r\nRegarding the three cases left, we can see different patterns like strings with all capital letters and other with all small letters (only two cases). We are going to obviate those cases because the tasks to refactor them could be, at least, tedious. Analyzing the **housename**, we see one numeric value `1` that should not be there and three street names that probably should not be there either. In the case of **city**, we have one case that starts with lowercase and should be corrected.\r\n\r\nWe are going to center our efforts analyzing the **street** value, looking mainly for unexpected street types or abbreviations and creating a *mapping* function to correct those values. That mapping can be viewed in the following dictionary:\r\n\r\n``` javascript\r\nmapping_street_types = {\r\n\t'ACCESO': 'Acceso',\r\n\t'AU': 'Autovía',\r\n\t'AUTOVIA': 'Autovía',\r\n\t'AVENIDA': 'Avenida',\r\n\t'BARRIO': 'Barrio',\r\n\t'B\\xba': 'Barrio',\r\n\t'C/': 'Calle',\r\n\t'CALLE': 'Calle',\r\n\t'CARRETERA': 'Carretera',\r\n\t'CL': 'Calle',\r\n\t'CR': 'Carretera',\r\n\t'CRTA.': 'Carretera',\r\n\t'CTRA.N-623,BURGOS-SANTANDER': 'Carretera N-623, Burgos-Santander',\r\n\t'Carretera/Carrera': 'Carretera',\r\n\t'Kalea': 'kalea',\r\n\t'PLAZA': 'Plaza',\r\n\t'POLIGONO': 'Polígono',\r\n\t'Urbanizaci\\xc3\\xb3n': 'Urbanización',\r\n\t'Urbanizaci\\xf3n': 'Urbanización'\r\n}\r\n```\r\n\r\nIn this case we are going to correct the street types that are in capital letters, but only the street type, not the rest of the string.\r\n\r\n## 5. Cleaning the data\r\n\r\nAs we have seen before, the final goal is to clean and store the OSM *Elements*, converting them into JSON documents and get them inside a MongoDB database. \r\n\r\nOnce we have identified the main problems we want to solve in the original data, we will create a procedure to clean it. The tasks we are going to do are the following:\r\n\r\n- [x] Nest *common* attributes (except *id* and *visible*) into a *creation* attribute.\r\n- [x] Create a *type* attribute (*node* or *way*).\r\n- [x] Create array with position for *nodes*.\r\n- [x] Create array for node references on *ways*.\r\n- [x] Re-organize attributes, creating nested elements for *namespaces*.\r\n- [x] Clean *tags* according the analysis we have made:\r\n      - [x] Errors in *keys*.\r\n      - [x] Errors in *values*.\r\n      - [x] Street types correction (ex. from `C/` to `Calle`).\r\n      - [ ] Others (like correct all-caps nomenclature).\r\n- [x] Create a JSON object for each *Element* (*node* or *way*) in the original document.\r\n- [x] Import all JSON objects into a MongoDB database.\r\n\r\nThis entire procedure (except the final step) can be found in the script [clean.py](./src/clean.py), which creates a [*cleaned.jsonl*](http://jsonlines.org/) file that we could import later to our MongoDB database using the [*mongoimport* tool](http://docs.mongodb.org/manual/reference/program/mongoimport/) as follows:\r\n\r\n``` shell\r\nmongoimport -d osm -c merindades --file cleaned.jsonl\r\n```\r\n\r\nWhere *osm* is the database name and *merindades* is the collection.\r\n\r\n## 6. Data Overview\r\n\r\n### 6.1 Documents\r\n\r\nAs we have seen before, we have the original OSM xml document and a cleaned version in JSON format. These documents have the following approximate size:\r\n\r\n``` \r\ndata.osm .......... 355 MB\r\ncleaned.jsonl ..... 430 MB\r\n```\r\n\r\n### 6.2 Database\r\n\r\n#### 6.2.1 General Overview\r\n\r\nNow that we have collected the data within a MongoDB database is time to run some queries to extract some insights about the OSM data. We are going to use the [*mongo* shell](http://docs.mongodb.org/v2.2/mongo/), a interactive JavaScript shell.\r\n\r\n- Total number of *Elements*:\r\n\r\n``` javascript\r\n> db.merindades.find().count()\r\n1855383\r\n```\r\n\r\n- Total number of *Nodes*:\r\n\r\n``` javascript\r\n> db.merindades.find({'type': 'node'}).count()\r\n1758132\r\n```\r\n\r\n- Total number of *Elements* that have a *null* value inside the **visible** attribute:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$group': {'_id': '$visible', 'count': {'$sum': 1}}}])\r\n{ \"_id\" : null, \"count\" : 1855383 }\r\n```\r\n\r\nIn our [clean.py](./src/clean.py) script we created an attribute *visible* for those cases where it would not exist, associating a *null* value (instead of a *true* or *false*). As we can see here, there is not any *Element* that has a *visible* attribute in the original OSM file, so all the documents we have in the database have a *null* value within the *visible* attribute.\r\n\r\n- Number of **places** aggregated by type:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$match': {'place': {'$exists': 1}}}, {'$group': {'_id': '$place', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}])\r\n{ \"_id\" : \"locality\", \"count\" : 12872 }\r\n{ \"_id\" : \"hamlet\", \"count\" : 1076 }\r\n{ \"_id\" : \"village\", \"count\" : 654 }\r\n{ \"_id\" : \"neighbourhood\", \"count\" : 206 }\r\n{ \"_id\" : \"isolated_dwelling\", \"count\" : 83 }\r\n{ \"_id\" : \"suburb\", \"count\" : 75 }\r\n{ \"_id\" : \"farm\", \"count\" : 8 }\r\n{ \"_id\" : \"town\", \"count\" : 8 }\r\n{ \"_id\" : \"yes\", \"count\" : 3 }\r\n{ \"_id\" : \"La Coteruca\", \"count\" : 1 }\r\n{ \"_id\" : \"state\", \"count\" : 1 }\r\n{ \"_id\" : \"city\", \"count\" : 1 }\r\n```\r\n\r\nHere we can see some values that should probably not be there, like **yes** or **La Coretuca**. We should have audit these error in previous stages of the process or update the documents in the database.\r\n\r\n- Number of unique users:\r\n\r\n``` javascript\r\n> db.merindades.distinct('created.user').length\r\n553\r\n```\r\n\r\n- Top 5 users by contributions:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$group': {'_id': '$created.user', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}, {'$limit': 5}])\r\n{ \"_id\" : \"cronoser\", \"count\" : 415038 }\r\n{ \"_id\" : \"Emilio Gomez\", \"count\" : 280561 }\r\n{ \"_id\" : \"sanchi\", \"count\" : 170710 }\r\n{ \"_id\" : \"jonbergor\", \"count\" : 123627 }\r\n{ \"_id\" : \"www_dorono_tk\", \"count\" : 65890 }\r\n```\r\n\r\nAs we could expect here, the contributions are highly skewed, the contribution percentage of these 5 is: *cronoser* 22.37%, *Emilio Gomez* 15.12%, *sanchi* 9.2%, *jonbergor* 6.67% and *www_dorono_tk* 3.55%. Moreover, these 5 users, that represent the **0.9% of the total users, have edited 56.91%** of the *Elements*.\r\n\r\n- Top 10 users by contribution:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$group': {'_id': '$created.user', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}, {'$limit': 10}, {'$group': {'_id': 'top_10_users', 'count': {'$sum': '$count'}}}])\r\n{ \"_id\" : \"top_10_users\", \"count\" : 1304382 }\r\n```\r\n\r\nHere we can see that the top 10 users by contribution have edited the 70.3% of the *Elements* in our database. That is, **1.8% of the total users have edited 70.3%** of the *Elements*.\r\n\r\n- Percentage of the *Elements* mapped by the top 5% users by contribution:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$group': {'_id': '$created.user', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}, {'$limit': 27}, {'$group': {'_id': 'top_10_users', 'count': {'$sum': '$count'}}}])\r\n{ \"_id\" : \"top_10_users\", \"count\" : 1660270 }\r\n```\r\n\r\nThe **89.48% of the *Elements* have been mapped by the 5% of the users**.\r\n\r\n- Top 10 types of **amenities**:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$match': {'amenity': {'$exists': 1}}}, {'$group': {'_id': '$amenity', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}, {'$limit': 10}])\r\n\r\n{ \"_id\" : \"place_of_worship\", \"count\" : 1052 }\r\n{ \"_id\" : \"drinking_water\", \"count\" : 868 }\r\n{ \"_id\" : \"parking\", \"count\" : 526 }\r\n{ \"_id\" : \"bar\", \"count\" : 336 }\r\n{ \"_id\" : \"restaurant\", \"count\" : 273 }\r\n{ \"_id\" : \"bank\", \"count\" : 210 }\r\n{ \"_id\" : \"school\", \"count\" : 209 }\r\n{ \"_id\" : \"cafe\", \"count\" : 140 }\r\n{ \"_id\" : \"pharmacy\", \"count\" : 124 }\r\n{ \"_id\" : \"fuel\", \"count\" : 122 }\r\n```\r\n\r\nNo surprise here, due to the fact that there is a church in almost every single village in Spain, no matter the size of it.\r\n\r\n- Grouping the *places of worship* by **religion**:\r\n\r\n``` javascript\r\n> db.merindades.aggregate([{'$match': {'amenity': {'$exists': 1}, 'amenity': 'place_of_worship'}}, {'$group': {'_id': '$religion', 'count': {'$sum': 1}}}, {'$sort': {'count': -1}}, {'$limit': 5}])\r\n{ \"_id\" : \"christian\", \"count\" : 1035 }\r\n{ \"_id\" : null, \"count\" : 16 }\r\n{ \"_id\" : \"muslim\", \"count\" : 1 }\r\n```\r\n\r\nAlso it would be likely that those that have no **religion** attribute (that appear as *null*) are also referring to *christian* religion.\r\n\r\n#### 6.2.2 Geospational Queries\r\n\r\nAs we said before, adding a position attribute to the *Nodes* allows us to query in terms of distance to a desired point. First of all we need to create the **geospational index**, in our *mongo* console:\r\n\r\n``` javascript\r\n> db.merindades.ensureIndex({'pos': '2d'})\r\n{\r\n\t\"createdCollectionAutomatically\" : false,\r\n\t\"numIndexesBefore\" : 1,\r\n\t\"numIndexesAfter\" : 2,\r\n\t\"ok\" : 1\r\n}\r\n```\r\n\r\nWe are going to use the *find* method to make our queries. Here we can use the [$near](http://docs.mongodb.org/manual/reference/operator/query/near/) operator, that returns the documents from nearest to farthest. We can also specify the maximum distance with the [$maxDistance](http://docs.mongodb.org/manual/reference/operator/query/maxDistance/) operator. Because we are specifying a [2d index](http://docs.mongodb.org/manual/core/2d/) with the *longitude* and *latitude* in our **pos** attribute in degrees, we need to specify the distance in the same units. Then, if we want to query within a distance in kilometers, we have to convert it by the following equation:\r\n\r\n``` \r\ndistance [º] = (distance [km] / earth_radius [km] ) * ( 180 º / π rad ) \r\n```\r\n\r\nwith and earth radius of 6378.1 km\r\n\r\nHere I am going to take the location reference of my hometown, *Medina de Pomar*, which has the following structure in the corresponding document within our database:\r\n\r\n``` javascript\r\n> db.merindades.find({'name': 'Medina de Pomar', 'place': 'town'}).pretty()\r\n{\r\n\t\"_id\" : ObjectId(\"55a690cbb4170bc4a83c30f1\"),\r\n\t\"admin_level\" : \"8\",\r\n\t\"name\" : \"Medina de Pomar\",\r\n\t\"created\" : {\r\n\t\t\"user\" : \"cronoser\",\r\n\t\t\"uid\" : \"461005\",\r\n\t\t\"timestamp\" : \"2015-03-24T15:24:11Z\",\r\n\t\t\"version\" : \"7\",\r\n\t\t\"changeset\" : \"29705846\"\r\n\t},\r\n\t\"ref\" : {\r\n\t\t\"ine\" : \"09209001100\"\r\n\t},\r\n\t\"wikipedia\" : \"es:Medina_de_Pomar\",\r\n\t\"pos\" : [\r\n\t\t-3.4861165,\r\n\t\t42.9322093\r\n\t],\r\n\t\"ele\" : \"607\",\r\n\t\"visible\" : null,\r\n\t\"place\" : \"town\",\r\n\t\"source\" : {\r\n\t\t\"ele\" : \"MDT5\",\r\n\t\t\"default\" : \"Instituto Geográfico Nacional\",\r\n\t\t\"date\" : \"2011-06\",\r\n\t\t\"name\" : \"Nomenclátor Geográfico de Municipios y Entidades de Población\",\r\n\t\t\"file\" : \"http://centrodedescargas.cnig.es/CentroDescargas/equipamiento/BD_Municipios-Entidades.zip\"\r\n\t},\r\n\t\"capital\" : \"8\",\r\n\t\"population\" : {\r\n\t\t\"default\" : \"6225\",\r\n\t\t\"date\" : \"2011\"\r\n\t},\r\n\t\"type\" : \"node\",\r\n\t\"id\" : \"492410974\",\r\n\t\"is_in\" : {\r\n\t\t\"default\" : \"Burgos, Castilla y León, Spain, Europe\",\r\n\t\t\"country\" : \"Spain\",\r\n\t\t\"municipality\" : \"Medina de Pomar\",\r\n\t\t\"country_code\" : \"ES\",\r\n\t\t\"province_code\" : \"09\"\r\n\t}\r\n}\r\n```\r\n\r\nWe just need to specify the location coordinates along with the *$near* command to get the values we want.\r\n\r\n- Number of *Elements* within a distance of **5 km**:\r\n\r\n``` javascript\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}}).count()\r\n50047\r\n```\r\n\r\n- Number of *Amenities* within a distance of **5 km**:\r\n\r\n``` javascript\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': {'$exists': 1}}).count()\r\n143\r\n```\r\n\r\n- Number of *bars*, *cafes* and *restaurants* within a distance of **5 km**.\r\n\r\n``` javascript\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': {'$in': ['bar', 'cafe', 'restaurant']}}).count()\r\n53\r\n```\r\n\r\nI was always impressed by the amount of this kind of places in my hometown, considering that it has an approximate population of 6.000 habitants.\r\n\r\n- Number of *schools*, *places of worship*, *pharmacies*, *banks* and *fuel stations* within a distance of **5 km**:\r\n\r\n``` javascript\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': 'school'}).count()\r\n1\r\n\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': 'place_of_worship'}).count()\r\n1\r\n\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': 'bank'}).count()\r\n6\r\n\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': 'pharmacy'}).count()\r\n4\r\n\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$maxDistance': (5 * (180/(Math.PI * 6378.1)))}, 'amenity': 'fuel'}).count()\r\n2\r\n```\r\n\r\n- Number of *places of worships* and *bars, cafes and restaurants* within a distance of **25 km**:\r\n\r\n``` javascript\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$minDistance': 0, '$maxDistance': (25 * (180/(Math.PI * 6578.1)))}, 'amenity': 'place_of_worship'}).count()  \r\n21\r\n\r\n> db.merindades.find({'pos': {'$near': [ -3.4861165, 42.9322093 ], '$minDistance': 0, '$maxDistance': (25 * (180/(Math.PI * 6578.1)))}, 'amenity': {'$in': ['bar', 'cafe', 'restaurant']}}).count()\r\n155\r\n```\r\n\r\nIf we increase the distance from the center of the town, we reach other small villages where each one of them would probably have its own church and probably several *bars* (at least in the bigger ones).\r\n\r\n## 7. Conclusion\r\n\r\nThrough all the stages of this project we have seen that we can find a wide variety or errors within the OSM data. We have centered our effort in analyzing only some of the fields, but **there is definitely more work to do if we want a completely cleaned data**. We have found errors in both *keys* and *values* of the different *tags*, and we have not only corrected them but also fixed some issues with the data, like creating various fields from one originally wrong (in case of *streets* that included also the number of the house and even the door letter). \r\n\r\nDespite our effort, the huge amount of different kind of *tags* make the cleaning process almost impossible if we do not center our efforts in the fields that we are interested in analyzing (like in this case the *address*). \r\n\r\nThe OSM edition process is too much open to interpretations and in some cases it is not clear what rule to apply while tagging an item. It seems that it is too complex to know all the procedures to apply or they are too complex for an average user to spent time reading the documentation before start editing (what leads in errors about *what-each-tag-means*).\r\n\r\nI also find particularly tricky to work with the absolutely freedom allowed while adding new tags. I think that a more-structured approach could benefit the overall experience while working with OSM data.\r\n\r\nApart from that, I think is incredible the power that a community could have while creating things together. Open Street Maps is without any doubt a great source of information and also it is probably the most recently actualized data (which depends on the activity of their users). ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}